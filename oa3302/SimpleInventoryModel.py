from simkit.base import SimEntityBase
from math import nan
"""
This is an implementation of a simple inventory model. Demand for items arrive periodically
and are either issued or backordered. When the net inventory level falls below a given threshold
(reorder_point), and an order of size order_quantity is placed. This oder arrives a "lead time"
later, generated by lead_time_generator.

This model illustrates a "transient" state variable, filled, whose mean will be tallied (rather
than using time-varying means)
"""
class InventoryModel(SimEntityBase):
    def __init__(self, inter_demand_genetaor, demand_generator, lead_time_generator, initial_on_hand, reorder_point, order_quantity):
        SimEntityBase.__init__(self)
        # Set each parameter to its value being passed in
        self.inter_demand_generator = inter_demand_genetaor
        self.demand_generator = demand_generator
        self.lead_time_generator = lead_time_generator
        self.initial_on_hand = initial_on_hand
        self.reorder_point = reorder_point
        self.order_quantity = order_quantity

        # State variables are initialized to be nan
        self.on_hand = nan
        self.backorder = nan
        self.on_order = nan
        self.filled = nan

    # Set on_hand to initial_on_hand, rest to 0.
    # Set filled to nan, since no demand has occurred yet.
    def reset(self):
        SimEntityBase.reset(self)
        self.on_hand = self.initial_on_hand
        self.backorder = 0
        self.on_order = 0
        self.filled = nan

    # Only notify the time-varying states' initial values, not filled;
    # Schedule the first demand
    def run(self):
        self.notify_state_change("on_hand", self.on_hand)
        self.notify_state_change("backorder", self.backorder)
        self.notify_state_change("on_order", self.on_order)

        self.schedule("demand", self.inter_demand_generator.generate())

    # Generate the quantity demanded and determine if it can be immediately filled
    # Compute the new on_hand and backorder quantities based on this new demand
    # Schedule the next demand.
    # If the net inventory (including on_order) falls below reorder_point,
    # schedule place_order
    def demand(self):
        demand = self.demand_generator.generate()
        if demand <= self.on_hand:
            self.filled = 1
        else:
            self.filled = 0
        self.notify_state_change("filled", self.filled)
        net = self.on_hand  - self.backorder - demand

        self.on_hand = max(0, net)
        self.notify_state_change("on_hand", self.on_hand)

        self.backorder = max(0, -net)
        self.notify_state_change("backorder", self.backorder)

        self.schedule("demand", self.inter_demand_generator.generate())

        if net + self.on_order <= self.reorder_point:
            self.schedule("place_order", 0.0)

    # Increment on_order by order_quantity
    # Schedule order_arrives with delay generated by lead_time_generator
    def place_order(self):
        self.on_order += self.order_quantity
        self.notify_state_change("on_order", self.on_order)

        self.schedule("order_arrives", self.lead_time_generator.generate())

    # Decrement on_order by order_quantity
    # Compute on_hand and backorder with this update
    # Note that no other event is scheduled
    def order_arrives(self):
        self.on_order -= self.order_quantity
        self.notify_state_change("on_order", self.on_order)

        net = self.on_hand - self.backorder + self.order_quantity
        self.on_hand = max(0, net)
        self.notify_state_change("on_hand", self.on_hand)

        self.backorder = max(0, -net)
        self.notify_state_change("backorder", self.backorder)

